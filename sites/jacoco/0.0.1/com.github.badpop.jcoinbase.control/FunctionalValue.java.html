<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FunctionalValue.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JCoinbase</a> &gt; <a href="index.source.html" class="el_package">com.github.badpop.jcoinbase.control</a> &gt; <span class="el_source">FunctionalValue.java</span></div><h1>FunctionalValue.java</h1><pre class="source lang-java linenums">/*
 * Original work Copyright 2020 Vavr, http://vavr.io
 * Original licence :
 * Copyright 2020 Vavr, http://vavr.io
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 * Modified work in 2021 by Alexis &quot;Bad_Pop&quot; Vachard
 * FunctionalValue is a really simplified version of the vavr Value adapted for JCoinbase's needs.
 * For more information, please take a look at the https://www.vavr.io/
 */
package com.github.badpop.jcoinbase.control;

import io.vavr.CheckedFunction0;
import io.vavr.Lazy;
import io.vavr.collection.Iterator;
import io.vavr.collection.Stream;
import io.vavr.control.Option;
import io.vavr.control.Try;

import java.util.Objects;
import java.util.Optional;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * Call result is a simplified version of the vavr {@link io.vavr.Value} adapted to the JCoinbase
 * needs. For more information, please take a look at the &lt;a href=&quot;https://www.vavr.io/&quot;&gt;vavr
 * site&lt;/a&gt;
 *
 * &lt;p&gt;Functional programming is all about values and transformation of values using functions. The
 * {@code FunctionalValue} type reflects the values in a functional setting. It can be seen as the
 * result of a partial function application. Hence the result may be undefined. If a value is
 * undefined, we say it is empty.
 *
 * &lt;p&gt;How the empty state is interpreted depends on the context, i.e. it may be &lt;em&gt;undefined&lt;/em&gt;,
 * &lt;em&gt;failed&lt;/em&gt;, &lt;em&gt;no elements&lt;/em&gt;, etc.
 *
 * &lt;p&gt;Basic operations:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #get()}
 *   &lt;li&gt;{@link #getOrElse(Object)}
 *   &lt;li&gt;{@link #getOrElse(Supplier)}
 *   &lt;li&gt;{@link #getOrElseThrow(Supplier)}
 *   &lt;li&gt;{@link #getOrElseTry(CheckedFunction0)}
 *   &lt;li&gt;{@link #getOrNull()}
 *   &lt;li&gt;{@link #map(Function)}
 * &lt;/ul&gt;
 *
 * Iterable extensions:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #contains(Object)}
 *   &lt;li&gt;{@link #exists(Predicate)}
 *   &lt;li&gt;{@link #forAll(Predicate)}
 *   &lt;li&gt;{@link #forEach(Consumer)}
 *   &lt;li&gt;{@link #iterator()}
 * &lt;/ul&gt;
 *
 * Side-effects:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #peek(Consumer)}
 * &lt;/ul&gt;
 *
 * Tests:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #isEmpty()}
 * &lt;/ul&gt;
 *
 * @param &lt;T&gt; The type of the wrapped value.
 */
@SuppressWarnings(&quot;unchecked&quot;)
public interface FunctionalValue&lt;T&gt; extends Iterable&lt;T&gt; {

  /**
   * Shortcut for {@code exists(e -&gt; Objects.equals(e, element))}, tests if the given {@code
   * element} is contained.
   *
   * @param element An Object of type A, may be null.
   * @return true, if element is contained, false otherwise.
   */
  default boolean contains(T element) {
<span class="fc" id="L101">    return exists(e -&gt; Objects.equals(e, element));</span>
  }

  /**
   * Checks, if an element exists such that the predicate holds.
   *
   * @param predicate A Predicate
   * @return true, if predicate holds for one or more elements, false otherwise
   * @throws NullPointerException if {@code predicate} is null
   */
  default boolean exists(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L112">    Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">    for (T t : this) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">      if (predicate.test(t)) {</span>
<span class="fc" id="L115">        return true;</span>
      }
<span class="fc" id="L117">    }</span>
<span class="fc" id="L118">    return false;</span>
  }

  /**
   * Checks if this {@code Value} is asynchronously (short: async) computed.
   *
   * &lt;p&gt;Methods of a {@code Value} instance that operate on the underlying value may block the
   * current thread until the value is present and the computation can be performed.
   *
   * @return true if this {@code Value} is async (like {@link io.vavr.concurrent.Future}), false
   *     otherwise.
   */
  default boolean isAsync() {
<span class="fc" id="L131">    return false;</span>
  }

  /**
   * Checks if this {@code Value} is lazily evaluated.
   *
   * @return true if this {@code Value} is lazy (like {@link Lazy} and {@link Stream}), false
   *     otherwise.
   */
  default boolean isLazy() {
<span class="fc" id="L141">    return false;</span>
  }

  /**
   * States whether this is a single-valued type.
   *
   * @return {@code true} if this is single-valued, {@code false} otherwise.
   */
  default boolean isSingleValued() {
<span class="fc" id="L150">    return true;</span>
  }

  /**
   * Checks, if the given predicate holds for all elements.
   *
   * @param predicate A Predicate
   * @return true, if the predicate holds for all elements, false otherwise
   * @throws NullPointerException if {@code predicate} is null
   */
  default boolean forAll(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L161">    Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">    return !exists(predicate.negate());</span>
  }

  /**
   * Gets the underlying functionalValue or throws if no functionalValue is present.
   *
   * &lt;p&gt;&lt;strong&gt;IMPORTANT! This method will throw an undeclared {@link Throwable} if {@code
   * isEmpty() == true} is true.&lt;/strong&gt;
   *
   * &lt;p&gt;Because the 'empty' state indicates that there is no functionalValue present that can be
   * returned, {@code get()} has to throw in such a case. Generally, implementing classes should
   * throw a {@link java.util.NoSuchElementException} if {@code isEmpty()} returns true.
   *
   * &lt;p&gt;However, there exist use-cases, where implementations may throw other exceptions. See {@link
   * Try#get()}.
   *
   * &lt;p&gt;&lt;strong&gt;Additional note:&lt;/strong&gt; Dynamic proxies will wrap an undeclared exception in a
   * {@link java.lang.reflect.UndeclaredThrowableException}.
   *
   * @return the underlying functionalValue if this is not empty, otherwise {@code get()} throws a
   *     {@code Throwable}
   */
  T get();

  /**
   * Returns the underlying functionalValue if present, otherwise {@code other}.
   *
   * @param other An alternative functionalValue.
   * @return A functionalValue of type {@code T}
   */
  default T getOrElse(T other) {
<span class="fc bfc" id="L193" title="All 2 branches covered.">    return isEmpty() ? other : get();</span>
  }

  /**
   * Returns the underlying functionalValue if present, otherwise {@code other}.
   *
   * @param supplier An alternative functionalValue supplier.
   * @return A functionalValue of type {@code T}
   * @throws NullPointerException if supplier is null
   */
  default T getOrElse(Supplier&lt;? extends T&gt; supplier) {
<span class="fc" id="L204">    Objects.requireNonNull(supplier, &quot;supplier is null&quot;);</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">    return isEmpty() ? supplier.get() : get();</span>
  }

  /**
   * Returns the underlying functionalValue if present, otherwise throws {@code supplier.get()}.
   *
   * @param &lt;X&gt; a Throwable type
   * @param supplier An exception supplier.
   * @return A functionalValue of type {@code T}.
   * @throws NullPointerException if supplier is null
   * @throws X if no functionalValue is present
   */
  default &lt;X extends Throwable&gt; T getOrElseThrow(Supplier&lt;X&gt; supplier) throws X {
<span class="fc" id="L218">    Objects.requireNonNull(supplier, &quot;supplier is null&quot;);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">    if (isEmpty()) {</span>
<span class="fc" id="L220">      throw supplier.get();</span>
    } else {
<span class="fc" id="L222">      return get();</span>
    }
  }

  /**
   * Returns the underlying functionalValue if present, otherwise returns the result of {@code
   * Try.of(supplier).get()}.
   *
   * @param supplier An alternative functionalValue supplier.
   * @return A functionalValue of type {@code T}.
   * @throws NullPointerException if supplier is null
   */
  default T getOrElseTry(CheckedFunction0&lt;? extends T&gt; supplier) {
<span class="fc" id="L235">    Objects.requireNonNull(supplier, &quot;supplier is null&quot;);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">    return isEmpty() ? Try.of(supplier).get() : get();</span>
  }

  /**
   * Returns the underlying functionalValue if present, otherwise {@code null}.
   *
   * @return A functionalValue of type {@code T} or {@code null}.
   */
  default T getOrNull() {
<span class="fc bfc" id="L245" title="All 2 branches covered.">    return isEmpty() ? null : get();</span>
  }

  /**
   * Checks, this {@code Value} is empty, i.e. if the underlying functionalValue is absent.
   *
   * @return false, if no underlying functionalValue is present, true otherwise.
   */
  boolean isEmpty();

  /**
   * Maps the underlying functionalValue to a different component type.
   *
   * @param mapper A mapper
   * @param &lt;U&gt; The new component type
   * @return A new functionalValue
   */
  &lt;U&gt; FunctionalValue&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper);

  /**
   * Performs the given {@code action} on the first element if this is an &lt;em&gt;eager&lt;/em&gt;
   * implementation. Performs the given {@code action} on all elements (the first immediately,
   * successive deferred), if this is a &lt;em&gt;lazy&lt;/em&gt; implementation.
   *
   * @param action The action that will be performed on the element(s).
   * @return this instance
   */
  FunctionalValue&lt;T&gt; peek(Consumer&lt;? super T&gt; action);

  /**
   * Returns a rich {@code io.vavr.collection.Iterator}.
   *
   * @return A new Iterator
   */
  @Override
  Iterator&lt;T&gt; iterator();

  /**
   * Converts this to an {@link java.util.Optional}.
   *
   * &lt;pre&gt;{@code
   * // = Optional.empty
   * Future.of(() -&gt; { throw new Error(); })
   *       .toJavaOptional()
   *
   * // = Optional[ok]
   * Try.of(() -&gt; &quot;ok&quot;)
   *     .toJavaOptional()
   *
   * // = Optional[1]
   * List.of(1, 2, 3)
   *     .toJavaOptional()
   * }&lt;/pre&gt;
   *
   * @return A new {@link java.util.Optional}.
   */
  default Optional&lt;T&gt; toJavaOptional() {
<span class="fc bfc" id="L302" title="All 2 branches covered.">    return isEmpty() ? Optional.empty() : Optional.ofNullable(get());</span>
  }

  /**
   * Converts this to a {@link CallResult}.
   *
   * @param leftSupplier A {@link Supplier} for the failure value for the {@link CallResult}
   * @param &lt;L&gt; Validation error component type
   * @return A new {@link CallResult}.
   */
  default &lt;L&gt; CallResult&lt;L, T&gt; toCallResult(Supplier&lt;? extends L&gt; leftSupplier) {
<span class="fc" id="L313">    Objects.requireNonNull(leftSupplier, &quot;leftSupplier is null&quot;);</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">    if (this instanceof CallResult) {</span>
<span class="fc" id="L315">      return ((CallResult&lt;?, T&gt;) this).mapLeft(ignored -&gt; leftSupplier.get());</span>
    } else {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">      return isEmpty() ? CallResult.failure(leftSupplier.get()) : CallResult.success(get());</span>
    }
  }

  /**
   * Converts this to a {@link CallResult}.
   *
   * @param left A failure value for the {@link CallResult}
   * @param &lt;L&gt; CallResult failure component type
   * @return A new {@link CallResult}.
   */
  default &lt;L&gt; CallResult&lt;L, T&gt; toCallResult(L left) {
<span class="fc bfc" id="L329" title="All 2 branches covered.">    if (this instanceof CallResult) {</span>
<span class="fc" id="L330">      return ((CallResult&lt;?, T&gt;) this).mapLeft(ignored -&gt; left);</span>
    } else {
<span class="fc bfc" id="L332" title="All 2 branches covered.">      return isEmpty() ? CallResult.failure(left) : CallResult.success(get());</span>
    }
  }

  /**
   * Converts this to an {@link Option}.
   *
   * @return A new {@link Option}.
   */
  default Option&lt;T&gt; toOption() {
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">    if (this instanceof Option) {</span>
<span class="nc" id="L343">      return (Option&lt;T&gt;) this;</span>
    } else {
<span class="fc bfc" id="L345" title="All 2 branches covered.">      return isEmpty() ? Option.none() : Option.some(get());</span>
    }
  }

  @Override
  default Spliterator&lt;T&gt; spliterator() {
<span class="fc" id="L351">    return Spliterators.spliterator(</span>
<span class="fc" id="L352">        iterator(),</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">        isEmpty() ? 0 : 1,</span>
        Spliterator.IMMUTABLE | Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED);
  }

  /**
   * Clarifies that functionalValues have a proper equals() method implemented.
   *
   * &lt;p&gt;See &lt;a
   * href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-&quot;&gt;Object.equals(Object)&lt;/a&gt;.
   *
   * @param o An object
   * @return true, if this equals o, false otherwise
   */
  @Override
  boolean equals(Object o);

  /**
   * Clarifies that functionalValues have a proper hashCode() method implemented.
   *
   * &lt;p&gt;See &lt;a
   * href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--&quot;&gt;Object.hashCode()&lt;/a&gt;.
   *
   * @return The hashcode of this object
   */
  @Override
  int hashCode();

  /**
   * Clarifies that functionalValues have a proper toString() method implemented.
   *
   * &lt;p&gt;See &lt;a
   * href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--&quot;&gt;Object.toString()&lt;/a&gt;.
   *
   * @return A String representation of this object
   */
  @Override
  String toString();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>